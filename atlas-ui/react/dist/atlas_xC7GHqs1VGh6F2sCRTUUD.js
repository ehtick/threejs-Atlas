import{D as g,S as I,g as v}from"./atlas_D5TkNrZ-UIh1OV1m_7qMi.js";import{G as b,y as f,C as p,M as u,O as M,U as _,W as S,X as D,t as R,n as C,T as O,S as E,A,V as x}from"./atlas_Bd-08EnGHvuA4jxvJ1T-8.js";const l={CRYSTAL_COUNT:{min:10,max:40},CRYSTAL_DISTANCE:{min:1.2,max:2.5},ORBITAL_SPEED:{min:1.1,max:4.6},DEBRIS_COUNT:{min:15,max:35},CONNECTION_PROBABILITY:.4};class w{group;crystals=[];debris=[];connections=[];params;rng;planetRadius;cosmicOffset;constructor(t,o={}){this.planetRadius=t;const i=o.seed||Math.floor(Math.random()*1e6);this.rng=new I(i),this.params={color:o.color||[.3,.8,1],crystalCount:o.crystalCount||Math.floor(this.rng.random()*(l.CRYSTAL_COUNT.max-l.CRYSTAL_COUNT.min)+l.CRYSTAL_COUNT.min),crystalDistance:o.crystalDistance||this.rng.random()*(l.CRYSTAL_DISTANCE.max-l.CRYSTAL_DISTANCE.min)+l.CRYSTAL_DISTANCE.min,orbitalSpeed:o.orbitalSpeed||this.rng.random()*(l.ORBITAL_SPEED.max-l.ORBITAL_SPEED.min)+l.ORBITAL_SPEED.min,debrisCount:o.debrisCount||Math.floor(this.rng.random()*(l.DEBRIS_COUNT.max-l.DEBRIS_COUNT.min)+l.DEBRIS_COUNT.min),cosmicOriginTime:o.cosmicOriginTime||g,seed:i},this.cosmicOffset=i%100*.1,this.group=new b,this.createCrystalFormations(),this.createDebrisField(),this.createConnections()}createCrystalFormations(){const t=this.params.crystalCount,o=this.planetRadius+this.params.crystalDistance;for(let i=0;i<t;i++){const e=o+this.rng.random()*1-.5,s=this.rng.random()*Math.PI,n=this.rng.random()*Math.PI*2,a=this.rng.random()*Math.PI*2,r=this.calculateOrbitalPosition(e,s,n,a),m=this.createCrystalGeometry(),h=new f({color:new p(this.params.color[0],this.params.color[1],this.params.color[2]),transparent:!0,opacity:.8,wireframe:!1}),c=new u(m,h);c.position.set(r.x,r.y,r.z),c.rotation.set(this.rng.random()*Math.PI*2,this.rng.random()*Math.PI*2,this.rng.random()*Math.PI*2),c.userData={distance:e,inclination:s,longitudeOfAscendingNode:n,initialAngle:a,orbitalSpeed:this.rng.random()*.3+.2,rotationSpeed:(this.rng.random()-.5)*.02,originalScale:1},this.crystals.push(c),this.group.add(c)}}createCrystalGeometry(){const t=Math.floor(this.rng.random()*4),o=this.planetRadius*(.04+this.rng.random()*.03);switch(t){case 0:return new R(o*.6,o*2,6);case 1:return new D(o,0);case 2:return new S(o*1.2,0);case 3:return new _(o,1);default:return new M(o,1)}}createDebrisField(){const t=this.params.debrisCount,o=this.planetRadius+this.params.crystalDistance+.5;for(let i=0;i<t;i++){const e=o+this.rng.random()*2-1,s=this.rng.random()*Math.PI,n=this.rng.random()*Math.PI*2,a=this.rng.random()*Math.PI*2,r=this.calculateOrbitalPosition(e,s,n,a),m=new S(this.planetRadius*.006,0),h=new f({color:new p(this.params.color[0]*.7,this.params.color[1]*.7,this.params.color[2]*.9),transparent:!0,opacity:.6}),c=new u(m,h);c.position.set(r.x,r.y,r.z),c.userData={distance:e,inclination:s,longitudeOfAscendingNode:n,initialAngle:a,orbitalSpeed:this.rng.random()*.8+.4,rotationSpeed:(this.rng.random()-.5)*.05},this.debris.push(c),this.group.add(c)}}createConnections(){for(let t=0;t<this.crystals.length;t++)for(let o=t+1;o<this.crystals.length;o++)if(this.rng.random()<l.CONNECTION_PROBABILITY){const i=this.crystals[t],e=this.crystals[o],s=[i.position.clone(),e.position.clone()],n=new C(s),a=this.planetRadius*.01,r=4,m=8,h=new O(n,m,a,r,!1),c=new E({uniforms:{time:{value:0},color:{value:new p(this.params.color[0],this.params.color[1],this.params.color[2])},opacity:{value:.4}},vertexShader:`
              uniform float time;
              varying vec2 vUv;
              varying float vIntensity;
              
              void main() {
                vUv = uv;
                vIntensity = sin(time * 3.0 + position.x * 10.0) * 0.5 + 0.5;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,fragmentShader:`
              uniform vec3 color;
              uniform float opacity;
              varying vec2 vUv;
              varying float vIntensity;
              
              void main() {
                float centerDistance = abs(vUv.y - 0.5) * 2.0;
                float tubeFalloff = 1.0 - smoothstep(0.0, 1.0, centerDistance);
                
                float finalOpacity = opacity * vIntensity * tubeFalloff;
                gl_FragColor = vec4(color, finalOpacity);
              }
            `,transparent:!0,blending:A,depthWrite:!1}),d=new u(h,c);d.renderOrder=997,d.userData={crystal1Index:t,crystal2Index:o,tubeRadius:a,tubularSegments:m,radialSegments:r},this.connections.push(d),this.group.add(d)}}calculateOrbitalPosition(t,o,i,e){const s=t*Math.cos(e),n=t*Math.sin(e),a=0,r=s,m=n*Math.cos(o)-a*Math.sin(o),h=n*Math.sin(o)+a*Math.cos(o),c=r*Math.cos(i)-m*Math.sin(i),d=r*Math.sin(i)+m*Math.cos(i),T=h;return new x(c,d,T)}update(t){const i=(v(this.params.cosmicOriginTime||g)+this.cosmicOffset)*(this.params.orbitalSpeed||1);this.crystals.forEach(e=>{const s=e.userData,n=s.initialAngle+i*s.orbitalSpeed*.1,a=this.calculateOrbitalPosition(s.distance,s.inclination,s.longitudeOfAscendingNode,n);e.position.set(a.x,a.y,a.z),e.rotation.x+=s.rotationSpeed,e.rotation.y+=s.rotationSpeed*.7,e.rotation.z+=s.rotationSpeed*1.3;const r=Math.sin(i*2+s.initialAngle)*.1+1;e.scale.setScalar(s.originalScale*r)}),this.debris.forEach(e=>{const s=e.userData,n=s.initialAngle+i*s.orbitalSpeed*.15,a=this.calculateOrbitalPosition(s.distance,s.inclination,s.longitudeOfAscendingNode,n);e.position.set(a.x,a.y,a.z),e.rotation.x+=s.rotationSpeed,e.rotation.y+=s.rotationSpeed*.8}),this.connections.forEach(e=>{const s=e.userData,n=this.crystals[s.crystal1Index],a=this.crystals[s.crystal2Index],r=[n.position,a.position],m=new C(r);e.geometry.dispose(),e.geometry=new O(m,s.tubularSegments,s.tubeRadius,s.radialSegments,!1);const h=e.material;h.uniforms.time.value=i})}getObject3D(){return this.group}addToScene(t,o){o&&this.group.position.copy(o),t.add(this.group)}removeFromScene(t){t.remove(this.group)}dispose(){this.crystals.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.debris.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.connections.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.group.clear()}setEnabled(t){this.group.visible=t}updateParams(t){if(Object.assign(this.params,t),t.color){const o=new p(t.color[0],t.color[1],t.color[2]);this.crystals.forEach(i=>{i.material.color=o}),this.connections.forEach(i=>{const e=i.material;e.uniforms.color.value=o})}}}function G(y,t,o){const e={seed:(o||Math.floor(Math.random()*1e6))+80002,color:t.color||[.3,.8,1],cosmicOriginTime:t?.timing?.cosmic_origin_time||t?.cosmicOriginTime||g};return new w(y,e)}export{w as L,G as c};
