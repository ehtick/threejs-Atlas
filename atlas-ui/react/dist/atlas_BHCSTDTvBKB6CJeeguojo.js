import{S as z}from"./atlas_ouOT0ykXceu4Q_V1lX7IB.js";import{V as u,S as N,D as L,C as A,G as M,E as F,B as I,L as E,M as V,g as w}from"./atlas_C0Xm8D4F9LGKGgzeG7E8_.js";const c={DOODLE_COUNT:{min:30,max:48},DOODLE_SIZE:{min:.08,max:.2},COMPLEXITY:{min:15,max:35},MOVEMENT_SPEED:{min:.03,max:.09},OPACITY:{min:.3,max:1},TIME_SPEED:{min:.1,max:3},RING_CYCLE_DURATION:{min:25,max:45},RING_EVENT_DURATION:{min:3,max:8},SEPARATION_DURATION:{min:.8,max:2.5},RETURNING_DURATION:{min:.8,max:2.5}};class U{group;doodles=[];doodleData=[];planetRadius;startTime;timeSpeed;rng;lightDirection=new u(1,1,1).normalize();lastDebugTime=0;debugInterval=30;debugMode=!1;cosmicRingState="normal";ringCycleDuration;ringEventDuration;separationDuration;returningDuration;doodleBasePositions=[];orbitalVisibilityFactor;orbitalData;currentTimeYears;createLitMaterial(t,i){const e=`
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        vWorldNormal = normalize(mat3(modelMatrix) * normal);
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,a=`
      uniform vec3 color;
      uniform float opacity;
      uniform vec3 lightDirection;
      uniform float ambientStrength;
      uniform float lightIntensity;
      
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      
      void main() {
        vec3 normal = normalize(vWorldNormal);
        vec3 lightDir = normalize(-lightDirection); // Negativo porque lightDirection apunta hacia la luz
        
        // Lambertian lighting with smooth day/night transition
        float dotNL = dot(normal, lightDir);
        float lightingFactor = max(0.0, dotNL); // Simple Lambertian
        
        // Rim lighting for enhanced visibility
        float rimLight = 1.0 - abs(dotNL);
        rimLight = pow(rimLight, 3.0) * 0.1;
        
        // Final lighting calculation with preserved color intensity
        float totalLight = ambientStrength + (lightIntensity * lightingFactor) + rimLight;
        totalLight = clamp(totalLight, 0.6, 1.2); // Higher minimum, allow slight overbrightening
        
        // Preserve color vibrancy by mixing original color with lit color
        vec3 finalColor = mix(color * 0.8, color * totalLight, 0.7);
        
        gl_FragColor = vec4(finalColor, opacity);
      }
    `;return new N({vertexShader:e,fragmentShader:a,uniforms:{color:{value:new A(t)},opacity:{value:i},lightDirection:{value:this.lightDirection.clone()},ambientStrength:{value:.5},lightIntensity:{value:.8}},transparent:!0,side:L})}projectPointOnSphere(t,i,e,a){const o=a.clone().normalize(),n=new u(0,1,0).cross(o).normalize();n.lengthSq()<.001&&n.set(1,0,0).cross(o).normalize();const r=o.clone().cross(n).normalize(),l=n.clone().multiplyScalar(t).add(r.clone().multiplyScalar(i));return o.clone().add(l).normalize().multiplyScalar(e)}constructor(t,i={},e){this.group=new M,this.planetRadius=t;const a=e||12345;this.rng=new z(a),this.startTime=a%1e4/1e3,this.timeSpeed=this.rng.uniform(c.TIME_SPEED.min,c.TIME_SPEED.max),this.ringEventDuration=this.rng.uniform(c.RING_EVENT_DURATION.min,c.RING_EVENT_DURATION.max),this.separationDuration=this.rng.uniform(c.SEPARATION_DURATION.min,c.SEPARATION_DURATION.max),this.returningDuration=this.rng.uniform(c.RETURNING_DURATION.min,c.RETURNING_DURATION.max);const o=this.rng.uniform(c.RING_CYCLE_DURATION.min,c.RING_CYCLE_DURATION.max);this.ringCycleDuration=o+this.ringEventDuration,this.orbitalData=i.orbitalData,this.currentTimeYears=i.currentTime||0,this.orbitalVisibilityFactor=this.calculateOrbitalVisibility(),this.debugMode=!1,this.doodleData=this.generateProceduralDoodles(),this.doodleData.length>0&&this.createDoodles()}generateProceduralDoodles(){const t=[],i=this.rng.randint(c.DOODLE_COUNT.min,c.DOODLE_COUNT.max),e=["arc","fractals","squiggle"],a=["wave","pulse","spiral"];for(let o=0;o<i;o++){const n=this.rng.random()*2*Math.PI,r=Math.acos(this.rng.random()*2-1),l=[Math.sin(r)*Math.cos(n),Math.sin(r)*Math.sin(n),Math.cos(r)],s=this.rng.randint(200,255),h=this.rng.randint(0,100),g=this.rng.randint(150,255),d=this.rng.uniform(c.OPACITY.min,c.OPACITY.max),p=`#${s.toString(16).padStart(2,"0")}${h.toString(16).padStart(2,"0")}${g.toString(16).padStart(2,"0")}`;t.push({position_3d:l,type:e[this.rng.randint(0,e.length-1)],size:this.rng.uniform(c.DOODLE_SIZE.min,c.DOODLE_SIZE.max),color:[p,d],complexity:this.rng.randint(c.COMPLEXITY.min,c.COMPLEXITY.max),movement_speed:this.rng.uniform(c.MOVEMENT_SPEED.min,c.MOVEMENT_SPEED.max),movement_pattern:a[this.rng.randint(0,a.length-1)]})}return t}createDoodles(){this.doodleData.forEach((t,i)=>{let e;switch(t.type){case"arc":e=this.createArcDoodle(t);break;case"fractals":e=this.createFractalDoodle(t);break;case"squiggle":e=this.createSquiggleDoodle(t);break;default:e=this.createSquiggleDoodle(t)}const a=new u(...t.position_3d).normalize();this.doodleBasePositions[i]=a.multiplyScalar(this.planetRadius),this.doodles.push(e),this.group.add(e)})}createArcDoodle(t){const i=new M,a=new F(0,0,t.size*this.planetRadius,t.size*this.planetRadius*.7,0,Math.PI*1.5,!1,0).getPoints(50),o=new I().setFromPoints(a),n=this.createLitMaterial(t.color[0],t.color[1]),r=new E(o,n);return i.add(r),i}createFractalDoodle(t){const i=new M,e=Math.floor(t.complexity*.6)+2,a=new u(...t.position_3d),o=this.planetRadius;for(let n=0;n<e;n++){const r=(this.rng.random()-.5)*t.size*this.planetRadius,l=(this.rng.random()-.5)*t.size*this.planetRadius,s=[],h=Math.floor(this.rng.random()*20)+8,g=this.rng.random()*t.size*this.planetRadius*.3+.1;for(let m=0;m<=h;m++){const D=m/h*Math.PI*2,S=g*(.7+this.rng.random()*.6),v=D+(this.rng.random()-.5)*.5,_=r+Math.cos(v)*S,R=l+Math.sin(v)*S,b=this.projectPointOnSphere(_,R,o,a);s.push(b)}s.push(s[0]);const d=new I().setFromPoints(s),p=this.createLitMaterial(t.color[0],t.color[1]),f=new E(d,p);i.add(f)}return i}createSquiggleDoodle(t){const i=new M,e=Math.floor(t.complexity*.8)+3,a=new u(...t.position_3d),o=this.planetRadius;for(let n=0;n<e;n++){const r=[],l=this.rng.random()*15+5;let s=(this.rng.random()-.5)*t.size*this.planetRadius,h=(this.rng.random()-.5)*t.size*this.planetRadius;for(let f=0;f<=l;f++){const m=this.projectPointOnSphere(s,h,o,a);r.push(m),s+=(this.rng.random()-.5)*t.size*this.planetRadius*.2,h+=(this.rng.random()-.5)*t.size*this.planetRadius*.2;const D=t.size*this.planetRadius*.8;s=Math.max(-D,Math.min(D,s)),h=Math.max(-D,Math.min(D,h))}const g=new I().setFromPoints(r),d=this.createLitMaterial(t.color[0],t.color[1]),p=new E(g,d);i.add(p)}return i}update(t){const e=(this.startTime+Date.now()/1e3*this.timeSpeed)%1e3,a=this.orbitalVisibilityFactor;if(this.orbitalVisibilityFactor=this.calculateOrbitalVisibility(),this.debugMode){const n=Date.now()/1e3;n-this.lastDebugTime>this.debugInterval&&(this.lastDebugTime=n,this.logOrbitalStatus()),a<=.001&&this.orbitalVisibilityFactor>.001||a>.001&&this.orbitalVisibilityFactor<=.001}if(!this.orbitalData||!this.orbitalData.enabled){this.cosmicRingState="normal",this.doodles.forEach(n=>{n.position.set(0,0,0)}),this.applyNormalAnimations(e);return}if(this.orbitalVisibilityFactor<=.001){this.cosmicRingState="normal",this.doodles.forEach(n=>{n.position.set(0,0,0)}),this.applyNormalAnimations(e);return}const o=e%this.ringCycleDuration;this.updateCosmicRingState(o),this.doodles.forEach((n,r)=>{const l=this.doodleData[r];if(!l)return;const s=this.calculateCosmicRingEffect(o,r),h=new u(0,0,0),g=this.doodleBasePositions[r],d=r%3,p=this.planetRadius*2.5,f=d*.3*this.planetRadius,m=g.clone().normalize().multiplyScalar(p+f),S=e*12,v=1+d*.4,_=S*v+r*(Math.PI*2/this.doodles.length),R=p*.08,b=new u().crossVectors(m,new u(0,1,0)).normalize();b.lengthSq()<.001&&b.set(1,0,0).cross(m.clone().normalize()).normalize();const x=new u().crossVectors(m.clone().normalize(),b).normalize(),C=m.clone().add(b.multiplyScalar(Math.cos(_)*R)).add(x.multiplyScalar(Math.sin(_)*R));let P;if(s.separationFactor<=.001)P=h.clone();else{let y=s.separationFactor;this.cosmicRingState==="separating"?y=this.easeOutQuart(y):this.cosmicRingState==="returning"&&(y=this.easeInOutCubic(y)),P=h.clone().lerp(C,y)}n.position.copy(P);const T=l.movement_speed*s.speedMultiplier;switch(l.movement_pattern){case"wave":n.rotation.z=Math.sin(e*T)*.2;break;case"pulse":n.rotation.z=Math.sin(e*T*2)*.15;break;case"spiral":n.rotation.z=e*T;break}})}calculateOrbitalVisibility(){if(!this.orbitalData||!this.orbitalData.enabled)return 1;const i=this.currentTimeYears%this.orbitalData.cycle_duration_years/this.orbitalData.cycle_duration_years,e=this.orbitalData.visible_duration_years/this.orbitalData.cycle_duration_years;if(i<e){const a=i/e;return a<.1?a/.1:a>.9?(1-a)/.1:1}else return 0}applyNormalAnimations(t){this.doodles.forEach((i,e)=>{const a=this.doodleData[e];if(!a)return;const o=a.movement_speed;switch(a.movement_pattern){case"wave":i.rotation.z=Math.sin(t*o)*.2;break;case"pulse":i.rotation.z=Math.sin(t*o*2)*.15;break;case"spiral":i.rotation.z=t*o;break}})}updateCosmicRingState(t){const i=this.ringCycleDuration-this.ringEventDuration;t<i?this.cosmicRingState="normal":t<i+this.separationDuration?this.cosmicRingState="separating":t<i+this.separationDuration+(this.ringEventDuration-this.separationDuration-this.returningDuration)?this.cosmicRingState="ring_mode":this.cosmicRingState="returning"}calculateCosmicRingEffect(t,i){const e=this.ringCycleDuration-this.ringEventDuration;let a=0,o=0,n=1;switch(this.cosmicRingState){case"normal":a=0,o=0,n=1;break;case"separating":const l=(t-e)/this.separationDuration;a=this.easeOutQuart(l),o=12,n=1+a*7;break;case"ring_mode":a=1,o=12,n=8;break;case"returning":const s=e+this.separationDuration+(this.ringEventDuration-this.separationDuration-this.returningDuration),h=(t-s)/this.returningDuration;a=1-this.easeInQuart(h),o=12,n=1+a*7;break}const r=i/this.doodles.length*.3;if(this.cosmicRingState==="separating"){const l=Math.max(0,(t-e-r*this.separationDuration)/this.separationDuration);a=this.easeOutQuart(l)}else if(this.cosmicRingState==="returning"){const l=e+this.separationDuration+(this.ringEventDuration-this.separationDuration-this.returningDuration),s=Math.max(0,(t-l-r*this.returningDuration)/this.returningDuration);a=1-this.easeInQuart(s)}return{separationFactor:a,orbitalSpeed:o,speedMultiplier:n}}smoothstep(t,i,e){const a=Math.max(0,Math.min(1,(e-t)/(i-t)));return a*a*(3-2*a)}logOrbitalStatus(){if(!this.orbitalData||!this.orbitalData.enabled)return;const t=this.currentTimeYears,i=t%this.orbitalData.cycle_duration_years/this.orbitalData.cycle_duration_years,e=this.orbitalData.visible_duration_years/this.orbitalData.cycle_duration_years,a=i<e,o=t%this.orbitalData.cycle_duration_years;let n;a?n=this.orbitalData.visible_duration_years-o:n=this.orbitalData.cycle_duration_years-o;const r=n*365.25,l=r*24,s=l*60;r>1?`${r.toFixed(1)}`:l>1?`${l.toFixed(1)}`:`${s.toFixed(1)}`}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}easeOutQuart(t){return 1-Math.pow(1-t,4)}easeInQuart(t){return t*t*t*t}updateLightDirection(t){this.lightDirection.copy(t).normalize(),this.doodles.forEach(i=>{i.traverse(e=>{e instanceof E&&e.material instanceof N&&e.material.uniforms.lightDirection&&e.material.uniforms.lightDirection.value.copy(this.lightDirection)})})}updateFromThreeLight(t){const i=t.position.clone().normalize();this.updateLightDirection(i)}addToScene(t,i){this.group.position.copy(i),t.add(this.group)}removeFromScene(t){t.remove(this.group)}getObject3D(){return this.group}dispose(){this.doodles.forEach(t=>{t.traverse(i=>{i instanceof V?(i.geometry.dispose(),i.material instanceof w&&i.material.dispose()):i instanceof E&&(i.geometry.dispose(),i.material instanceof w&&i.material.dispose())})}),this.doodles=[]}}function G(O,t,i,e){const a=e?.timing?.elapsed_time?e.timing.elapsed_time/31557600:0,o=e?.surface_elements?.exotic_doodles;return new U(O,{planetRadius:O,orbitalData:o,currentTime:a},i)}export{U as E,G as c};
