import{S as A}from"./atlas_CMUvaCD4mo7XQYkYXSJfw.js";import{G as R,V as f,Q as S,C as u,L as C,B as T,r as d,i as B}from"./atlas_Ce3hh0hgxYWauQ_qSK6cl.js";class D{riverGroup;riverLines=[];params;rng;constructor(e,o={}){const t=o.seed||Math.floor(Math.random()*1e6);this.rng=new A(t),this.params={riverCount:o.riverCount||3,color:o.color||[0,0,0],opacity:o.opacity||.5,elevation:o.elevation||.008,seed:t},this.riverGroup=new R,this.generateBasicRivers(e)}generateBasicRivers(e){const o=e+e*this.params.elevation;for(let t=0;t<this.params.riverCount;t++){const r=this.createSingleRiver(o,t);r&&(this.riverLines.push(r),this.riverGroup.add(r))}}createSingleRiver(e,o){const t=this.rng.uniform(-.6,.6),r=this.rng.uniform(0,Math.PI*2);let n=new f(Math.cos(r)*Math.cos(t)*e,Math.sin(t)*e,Math.sin(r)*Math.cos(t)*e);const i=[n.clone()];let a=this.getRandomTangentDirection(n,e);const l=25+Math.floor(this.rng.uniform(0,10));for(let c=1;c<l;c++){const v=c/l,g=Math.sin(v*Math.PI*2)*.2,y=this.rng.uniform(-.1,.1),p=(g+y)*.3,h=n.clone().normalize(),s=new S().setFromAxisAngle(h,p);a.applyQuaternion(s).normalize();const m=e*.025;n=n.clone().add(a.clone().multiplyScalar(m)),n.normalize().multiplyScalar(e),a=this.keepDirectionTangent(a,n,e),i.push(n.clone())}return this.createLineFromPoints(i,o)}getRandomTangentDirection(e,o){const t=e.clone().normalize(),r=Math.abs(t.y)<.9?new f(0,1,0):new f(1,0,0),n=new f().crossVectors(t,r).normalize(),i=this.rng.uniform(0,Math.PI*2),a=new S().setFromAxisAngle(t,i);return n.applyQuaternion(a)}keepDirectionTangent(e,o,t){const r=o.clone().normalize(),n=e.dot(r);return e.clone().sub(r.clone().multiplyScalar(n)).normalize()}createLineFromPoints(e,o){if(e.length<2)return null;const t=new R,r=this.params.color instanceof u?this.params.color.clone():new u().setRGB(this.params.color[0],this.params.color[1],this.params.color[2]),n=o*.05;r.multiplyScalar(1-n*.2);const i=new C({color:r,opacity:this.params.opacity,transparent:this.params.opacity<1,depthWrite:!1,depthTest:!0}),a=new T().setFromPoints(e),l=new d(a,i);l.renderOrder=1e3,t.add(l);const c=.003;for(let v of[-c,c]){const g=e.map((s,m)=>{let M;if(m<e.length-1){const L=e[m+1].clone().sub(s).normalize(),G=s.clone().normalize();M=L.clone().cross(G).normalize()}else{const L=s.clone().sub(e[m-1]).normalize(),G=s.clone().normalize();M=L.clone().cross(G).normalize()}return s.clone().add(M.multiplyScalar(v))}),y=new T().setFromPoints(g),p=i.clone();p.opacity=this.params.opacity*.8;const h=new d(y,p);h.renderOrder=1e3,t.add(h)}return t}addToScene(e,o){o&&this.riverGroup.position.copy(o),e.add(this.riverGroup)}update(e){}updateParams(e){this.params={...this.params,...e},(e.color||e.opacity)&&this.riverLines.forEach(o=>{o.children.forEach(t=>{if(t instanceof d&&t.material instanceof C){if(e.color){const r=e.color instanceof u?e.color:new u().setRGB(e.color[0],e.color[1],e.color[2]);t.material.color=r}e.opacity!==void 0&&(t.material.opacity=e.opacity,t.material.transparent=e.opacity<1)}})})}getObject3D(){return this.riverGroup}dispose(){this.riverLines.forEach(e=>{e.children.forEach(o=>{o instanceof d&&(o.geometry.dispose(),o.material instanceof B&&o.material.dispose())})}),this.riverLines=[],this.riverGroup.clear()}}function b(z,e,o){console.log("Creating ULTRA SIMPLE dried river lines for arid planet");const r=(o||Math.floor(Math.random()*1e6))+8e3,n=e.river_data||e.dried_rivers||{},i={riverCount:Math.min(4,Math.max(2,n.count||3)),color:n.color||[0,0,0],opacity:n.opacity||.5,elevation:n.elevation||.008,seed:r};return console.log(`Creating ${i.riverCount} ULTRA SIMPLE dried river lines (seed: ${r})`),new D(z,i)}export{D as R,b as c};
