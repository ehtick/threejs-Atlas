import{D as g,S as I}from"./atlas_CtOhIAiNHzSpXytHIyKwk.js";import{G as b,z as f,C as p,M as u,O as v,U as D,W as S,X as M,t as _,n as C,T as O,S as R,A as E,V as A}from"./atlas_pGQiCQeTD5l6dMUXRRcYJ.js";const m={CRYSTAL_COUNT:{min:10,max:40},CRYSTAL_DISTANCE:{min:1.2,max:2.5},ORBITAL_SPEED:{min:1.1,max:4.6},DEBRIS_COUNT:{min:15,max:35},CONNECTION_PROBABILITY:.4};class x{group;crystals=[];debris=[];connections=[];params;rng;planetRadius;cosmicOffset;constructor(t,o={}){this.planetRadius=t;const i=o.seed||Math.floor(Math.random()*1e6);this.rng=new I(i),this.params={color:o.color||[.3,.8,1],crystalCount:o.crystalCount||Math.floor(this.rng.random()*(m.CRYSTAL_COUNT.max-m.CRYSTAL_COUNT.min)+m.CRYSTAL_COUNT.min),crystalDistance:o.crystalDistance||this.rng.random()*(m.CRYSTAL_DISTANCE.max-m.CRYSTAL_DISTANCE.min)+m.CRYSTAL_DISTANCE.min,orbitalSpeed:o.orbitalSpeed||this.rng.random()*(m.ORBITAL_SPEED.max-m.ORBITAL_SPEED.min)+m.ORBITAL_SPEED.min,debrisCount:o.debrisCount||Math.floor(this.rng.random()*(m.DEBRIS_COUNT.max-m.DEBRIS_COUNT.min)+m.DEBRIS_COUNT.min),cosmicOriginTime:o.cosmicOriginTime||g,seed:i},this.cosmicOffset=i%100*.1,this.group=new b,this.createCrystalFormations(),this.createDebrisField(),this.createConnections()}createCrystalFormations(){const t=this.params.crystalCount,o=this.planetRadius+this.params.crystalDistance;for(let i=0;i<t;i++){const n=o+this.rng.random()*1-.5,e=this.rng.random()*Math.PI,s=this.rng.random()*Math.PI*2,r=this.rng.random()*Math.PI*2,a=this.calculateOrbitalPosition(n,e,s,r),l=this.createCrystalGeometry(),h=new f({color:new p(this.params.color[0],this.params.color[1],this.params.color[2]),transparent:!0,opacity:.8,wireframe:!1}),c=new u(l,h);c.position.set(a.x,a.y,a.z),c.rotation.set(this.rng.random()*Math.PI*2,this.rng.random()*Math.PI*2,this.rng.random()*Math.PI*2),c.userData={distance:n,inclination:e,longitudeOfAscendingNode:s,initialAngle:r,orbitalSpeed:this.rng.random()*.3+.2,rotationSpeed:(this.rng.random()-.5)*.02,originalScale:1},this.crystals.push(c),this.group.add(c)}}createCrystalGeometry(){const t=Math.floor(this.rng.random()*4),o=this.planetRadius*(.04+this.rng.random()*.03);switch(t){case 0:return new _(o*.6,o*2,6);case 1:return new M(o,0);case 2:return new S(o*1.2,0);case 3:return new D(o,1);default:return new v(o,1)}}createDebrisField(){const t=this.params.debrisCount,o=this.planetRadius+this.params.crystalDistance+.5;for(let i=0;i<t;i++){const n=o+this.rng.random()*2-1,e=this.rng.random()*Math.PI,s=this.rng.random()*Math.PI*2,r=this.rng.random()*Math.PI*2,a=this.calculateOrbitalPosition(n,e,s,r),l=new S(this.planetRadius*.006,0),h=new f({color:new p(this.params.color[0]*.7,this.params.color[1]*.7,this.params.color[2]*.9),transparent:!0,opacity:.6}),c=new u(l,h);c.position.set(a.x,a.y,a.z),c.userData={distance:n,inclination:e,longitudeOfAscendingNode:s,initialAngle:r,orbitalSpeed:this.rng.random()*.8+.4,rotationSpeed:(this.rng.random()-.5)*.05},this.debris.push(c),this.group.add(c)}}createConnections(){for(let t=0;t<this.crystals.length;t++)for(let o=t+1;o<this.crystals.length;o++)if(this.rng.random()<m.CONNECTION_PROBABILITY){const i=this.crystals[t],n=this.crystals[o],e=[i.position.clone(),n.position.clone()],s=new C(e),r=this.planetRadius*.01,a=4,l=8,h=new O(s,l,r,a,!1),c=new R({uniforms:{time:{value:0},color:{value:new p(this.params.color[0],this.params.color[1],this.params.color[2])},opacity:{value:.4}},vertexShader:`
              uniform float time;
              varying vec2 vUv;
              varying float vIntensity;
              
              void main() {
                vUv = uv;
                vIntensity = sin(time * 3.0 + position.x * 10.0) * 0.5 + 0.5;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,fragmentShader:`
              uniform vec3 color;
              uniform float opacity;
              varying vec2 vUv;
              varying float vIntensity;
              
              void main() {
                float centerDistance = abs(vUv.y - 0.5) * 2.0;
                float tubeFalloff = 1.0 - smoothstep(0.0, 1.0, centerDistance);
                
                float finalOpacity = opacity * vIntensity * tubeFalloff;
                gl_FragColor = vec4(color, finalOpacity);
              }
            `,transparent:!0,blending:E,depthWrite:!1}),d=new u(h,c);d.renderOrder=997,d.userData={crystal1Index:t,crystal2Index:o,tubeRadius:r,tubularSegments:l,radialSegments:a},this.connections.push(d),this.group.add(d)}}calculateOrbitalPosition(t,o,i,n){const e=t*Math.cos(n),s=t*Math.sin(n),r=0,a=e,l=s*Math.cos(o)-r*Math.sin(o),h=s*Math.sin(o)+r*Math.cos(o),c=a*Math.cos(i)-l*Math.sin(i),d=a*Math.sin(i)+l*Math.cos(i),T=h;return new A(c,d,T)}update(t){const n=(Date.now()/1e3-(this.params.cosmicOriginTime||g)+this.cosmicOffset)*(this.params.orbitalSpeed||1);this.crystals.forEach(e=>{const s=e.userData,r=s.initialAngle+n*s.orbitalSpeed*.1,a=this.calculateOrbitalPosition(s.distance,s.inclination,s.longitudeOfAscendingNode,r);e.position.set(a.x,a.y,a.z),e.rotation.x+=s.rotationSpeed,e.rotation.y+=s.rotationSpeed*.7,e.rotation.z+=s.rotationSpeed*1.3;const l=Math.sin(n*2+s.initialAngle)*.1+1;e.scale.setScalar(s.originalScale*l)}),this.debris.forEach(e=>{const s=e.userData,r=s.initialAngle+n*s.orbitalSpeed*.15,a=this.calculateOrbitalPosition(s.distance,s.inclination,s.longitudeOfAscendingNode,r);e.position.set(a.x,a.y,a.z),e.rotation.x+=s.rotationSpeed,e.rotation.y+=s.rotationSpeed*.8}),this.connections.forEach(e=>{const s=e.userData,r=this.crystals[s.crystal1Index],a=this.crystals[s.crystal2Index],l=[r.position,a.position],h=new C(l);e.geometry.dispose(),e.geometry=new O(h,s.tubularSegments,s.tubeRadius,s.radialSegments,!1);const c=e.material;c.uniforms.time.value=n})}getObject3D(){return this.group}addToScene(t,o){o&&this.group.position.copy(o),t.add(this.group)}removeFromScene(t){t.remove(this.group)}dispose(){this.crystals.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.debris.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.connections.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.group.clear()}setEnabled(t){this.group.visible=t}updateParams(t){if(Object.assign(this.params,t),t.color){const o=new p(t.color[0],t.color[1],t.color[2]);this.crystals.forEach(i=>{i.material.color=o}),this.connections.forEach(i=>{const n=i.material;n.uniforms.color.value=o})}}}function N(y,t,o){const n={seed:(o||Math.floor(Math.random()*1e6))+80002,color:t.color||[.3,.8,1],cosmicOriginTime:t?.timing?.cosmic_origin_time||t?.cosmicOriginTime||g};return new x(y,n)}export{x as L,N as c};
