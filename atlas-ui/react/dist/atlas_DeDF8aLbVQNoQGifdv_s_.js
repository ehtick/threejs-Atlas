import{S as ot}from"./atlas_D5TkNrZ-UIh1OV1m_7qMi.js";import{G as lt,C as I,V as v,B as dt,g as R,q as tt,u as ht,v as ft,M as et,p as ut,i as Mt}from"./atlas_Bd-08EnGHvuA4jxvJ1T-8.js";class nt{landGroup;lands=[];constructor(d,c={}){this.landGroup=new lt;const u=c.seed||Math.floor(Math.random()*1e6),f=new ot(u);c.greenPatches&&c.greenPatches.length>0?this.generateLandsFromPython(d,c.greenPatches,f,c):this.generateProceduralLands(d,f,c)}generateLandsFromPython(d,c,u,f){const h=c.map(s=>{let l=s.position_3d||s.position||[0,0,1];if(l.length===2){const b=u.uniform(0,Math.PI*2),V=Math.acos(u.uniform(-1,1));l=[Math.sin(V)*Math.cos(b),Math.sin(V)*Math.sin(b),Math.cos(V)]}let r=new I(4881497),P=1;return s.color&&Array.isArray(s.color)&&(r=new I(s.color[0],s.color[1],s.color[2]),s.color.length>3&&(P=s.color[3])),{position:new v(l[0],l[1],l[2]).normalize(),size:(s.size||.1)*d*1.8*1.5,color:r,opacity:P,seed:u.uniform(0,1e4)}}),p=h.map((s,l)=>l),y=s=>(p[s]!==s&&(p[s]=y(p[s])),p[s]),F=(s,l)=>{const r=y(s),P=y(l);r!==P&&(p[r]=P)};for(let s=0;s<h.length;s++)for(let l=s+1;l<h.length;l++){const r=Math.acos(Math.min(1,Math.max(-1,h[s].position.dot(h[l].position)))),P=r*d,b=h[s].size+h[l].size,V=b*.15,O=Math.PI/6;P<b+V&&r<O&&F(s,l)}const z=new Map;for(let s=0;s<h.length;s++){const l=y(s);z.has(l)||z.set(l,[]),z.get(l).push(s)}z.forEach(s=>{const l=s.map(r=>h[r]);this.generateMergedLandmass(d,l,u,f)})}generateMergedLandmass(d,c,u,f){const h=new v;let p=0;c.forEach(t=>{h.add(t.position.clone().multiplyScalar(t.size)),p+=t.size}),h.divideScalar(p).normalize();let y=0;c.forEach(t=>{const e=Math.acos(Math.min(1,Math.max(-1,h.dot(t.position))));y=Math.max(y,e*d+t.size)});const F=d*Math.tan(Math.PI/5),z=Math.min(y*1.2,F),s=new I(0,0,0);let l=0;c.forEach(t=>{s.r+=t.color.r*t.size,s.g+=t.color.g*t.size,s.b+=t.color.b*t.size,l+=t.opacity*t.size}),s.multiplyScalar(1/p),l/=p;const r=Math.max(48,Math.min(80,Math.floor(z*40))),P=c[0]?.seed||0,b=new v,V=new v;Math.abs(h.y)<.99?b.crossVectors(h,new v(0,1,0)).normalize():b.crossVectors(h,new v(1,0,0)).normalize(),V.crossVectors(h,b).normalize();const O=(t,e,n=0)=>{const o=(_,it)=>{const ct=_*127.1+it*311.7+n;return Math.sin(ct)*43758.5453%1},a=Math.floor(t),i=Math.floor(e),M=t-a,x=e-i,G=_=>_*_*(3-2*_),w=G(M),g=G(x),D=o(a,i),$=o(a+1,i),W=o(a,i+1),k=o(a+1,i+1);return D*(1-w)*(1-g)+$*w*(1-g)+W*(1-w)*g+k*w*g},L=(t,e)=>{let n=0,o=1,a=2,i=0;for(let M=0;M<4;M++)n+=O(t*a,e*a,P+M*100)*o,i+=o,o*=.5,a*=2;return n/i},st=t=>{let e=0;for(const n of c){const o=Math.min(1,Math.max(-1,t.dot(n.position))),i=Math.acos(o)*d,M=Math.atan2(t.clone().sub(n.position).dot(V),t.clone().sub(n.position).dot(b)),G=1+(L(Math.cos(M)*3+n.seed*.01,Math.sin(M)*3)-.5)*.4,w=n.size*G,g=i/w;if(g<1.5){const D=Math.max(0,1-g);e+=D*D*(3-2*D)}}return e},E=.2,S=[],U=[],X=[],T=[],C=[],N=2.8,Y=(t,e,n)=>{const o=Math.max(0,Math.min(1,(n-t)/(e-t)));return o*o*(3-2*o)};for(let t=0;t<=r;t++){T[t]=[],C[t]=[];for(let e=0;e<=r;e++){const n=(t/r-.5)*N,o=(e/r-.5)*N,a=n*z,i=o*z,x=new v().addScaledVector(b,a).addScaledVector(V,i).add(h.clone().multiplyScalar(d)).clone().normalize(),G=.2,w=.5-Math.abs(n/N),g=.5-Math.abs(o/N),D=Y(0,G,w),$=Y(0,G,g),W=D*$;C[t][e]=x,T[t][e]=st(x)*W}}const H=(t,e)=>{if(T[t][e]<=E)return!1;const n=[[t-1,e],[t+1,e],[t,e-1],[t,e+1]];for(const[o,a]of n)if(!(o<0||o>r||a<0||a>r)&&T[o][a]<=E)return!0;return!1},A=new Map;let J=0;const K=d*1.012;for(let t=0;t<=r;t++)for(let e=0;e<=r;e++){const n=T[t][e];if(n>E){let o=C[t][e].clone();if(H(t,e)){const i=[[t-1,e,1],[t+1,e,1],[t,e-1,1],[t,e+1,1],[t-1,e-1,.7],[t+1,e-1,.7],[t-1,e+1,.7],[t+1,e+1,.7]];let M=new v,x=0,G=new v;for(const[w,g,D]of i){if(w<0||w>r||g<0||g>r)continue;const $=T[w][g];if($<=E){const W=Math.max(0,Math.min(1,(E-n)/($-n))),k=o.clone().lerp(C[w][g],W);M.addScaledVector(k.clone().sub(o),D),G.add(C[w][g].clone().sub(o)),x+=D}}if(x>0){M.divideScalar(x).multiplyScalar(.95),o.add(M).normalize(),G.normalize();const w=new v().crossVectors(o,G).normalize(),g=t*.1+e*.13+P*.001,D=(L(g,g*1.7)-.5)*2;o.addScaledVector(w,D*.012).normalize()}}const a=o.multiplyScalar(K);S.push(a.x,a.y,a.z),X.push(t/r,e/r),A.set(`${t},${e}`,J),J++}}const m=new Map;for(let t=0;t<r;t++)for(let e=0;e<r;e++){const n=A.get(`${t},${e}`),o=A.get(`${t+1},${e}`),a=A.get(`${t},${e+1}`),i=A.get(`${t+1},${e+1}`);n!==void 0&&o!==void 0&&a!==void 0&&(U.push(n,o,a),m.has(n)||m.set(n,[]),m.has(o)||m.set(o,[]),m.has(a)||m.set(a,[]),m.get(n).push(o,a),m.get(o).push(n,a),m.get(a).push(n,o)),o!==void 0&&i!==void 0&&a!==void 0&&(U.push(o,i,a),m.has(o)||m.set(o,[]),m.has(i)||m.set(i,[]),m.has(a)||m.set(a,[]),m.get(o).push(i,a),m.get(i).push(o,a),m.get(a).push(o,i))}if(S.length===0)return;const Q=new Set;for(let t=0;t<=r;t++)for(let e=0;e<=r;e++){const n=A.get(`${t},${e}`);n!==void 0&&H(t,e)&&Q.add(n)}const at=1,rt=.4;for(let t=0;t<at;t++){const e=[];for(let n=0;n<S.length/3;n++){const o=new v(S[n*3],S[n*3+1],S[n*3+2]);if(Q.has(n)){const a=m.get(n);if(a&&a.length>0){const i=[...new Set(a)],M=new v;for(const x of i)M.add(new v(S[x*3],S[x*3+1],S[x*3+2]));M.divideScalar(i.length),o.lerp(M,rt),o.normalize().multiplyScalar(K)}}e.push(o)}for(let n=0;n<e.length;n++)S[n*3]=e[n].x,S[n*3+1]=e[n].y,S[n*3+2]=e[n].z}const j=new dt;j.setAttribute("position",new R(S,3)),j.setAttribute("uv",new R(X,2)),j.setIndex(U),j.computeVertexNormals();const Z=new tt({color:f.transparentMode?new I(15135743):s,opacity:f.transparentMode?.3:l,transparent:f.transparentMode||l<1,emissive:f.transparentMode?new I(13428479).multiplyScalar(.1):s.clone().multiplyScalar(.05),emissiveIntensity:f.transparentMode?.05:1e-7,shininess:f.transparentMode?30:8,flatShading:!1,depthWrite:!0,depthTest:!0,polygonOffset:!0,polygonOffsetFactor:-1,polygonOffsetUnits:-1});if(!f.transparentMode){const e=document.createElement("canvas");e.width=e.height=32;const n=e.getContext("2d"),o=n.createImageData(32,32);for(let i=0;i<o.data.length;i+=4){const M=200+Math.floor(Math.random()*55);o.data[i]=M,o.data[i+1]=M,o.data[i+2]=M,o.data[i+3]=255}n.putImageData(o,0,0);const a=new ht(e);a.wrapS=a.wrapT=ft,a.repeat.set(4,4),Z.map=a}const B=new et(j,Z);B.castShadow=!0,B.receiveShadow=!0,B.renderOrder=1,this.lands.push(B),this.landGroup.add(B)}generateProceduralLands(d,c,u){const f=Math.floor(c.uniform(5,15));for(let h=0;h<f;h++){const p=c.uniform(0,Math.PI*2),y=Math.acos(c.uniform(-1,1)),F=new v(Math.sin(y)*Math.cos(p),Math.sin(y)*Math.sin(p),Math.cos(y)),z=d*c.uniform(.02,.08),s=new ut(z,16),l=F.clone().multiplyScalar(d*1.002);s.lookAt(F),s.translate(l.x,l.y,l.z);const r=c.uniform(.3,.7),P=new I(.36*(1-r)+.22*r,.23*(1-r)+.36*r,0),V=u.tundraMode||!1?.25:1,O=new tt({color:u.transparentMode?new I(15135743):P,opacity:u.transparentMode?.3:V,transparent:u.transparentMode||V<1,emissive:u.transparentMode?new I(13428479).multiplyScalar(.1):657920,shininess:u.transparentMode?30:5,depthWrite:!0,depthTest:!0}),L=new et(s,O);L.renderOrder=1,this.lands.push(L),this.landGroup.add(L)}}addToScene(d,c){c&&this.landGroup.position.copy(c),d.add(this.landGroup)}update(d,c){c!==void 0&&(this.landGroup.rotation.y=c)}getObject3D(){return this.landGroup}dispose(){this.lands.forEach(d=>{d.geometry.dispose(),d.material instanceof Mt&&d.material.dispose()}),this.lands=[],this.landGroup.clear()}}function pt(q,d,c){const u=d.green_patches;if(!u||u.length===0)return null;const f=c||Math.floor(Math.random()*1e6);return new nt(q,{greenPatches:u,seed:f+6e3})}function wt(q,d,c){const u=c||Math.floor(Math.random()*1e6),f=new ot(u+7e3),h=Math.floor(f.uniform(3,8)),p=[];for(let y=0;y<h;y++){const F=f.uniform(0,Math.PI*2),z=Math.acos(f.uniform(-1,1));p.push({position_3d:[Math.sin(z)*Math.cos(F),Math.sin(z)*Math.sin(F),Math.cos(z)],size:f.uniform(.05,.15),sides:Math.floor(f.uniform(8,16)),color:[0,0,0]})}return new nt(q,{greenPatches:p,seed:u+7e3,transparentMode:!0})}export{nt as L,wt as a,pt as c};
