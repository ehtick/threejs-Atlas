import{S as z}from"./atlas_C0O52P_24VXpcB_jxaut3.js";import{V as g,S as N,D as C,C as L,G as M,E as A,B as I,L as v,M as F,h as w}from"./atlas_DfFO9DeAqJfHmKzNHJUiw.js";const s={DOODLE_COUNT:{min:30,max:48},DOODLE_SIZE:{min:.08,max:.2},COMPLEXITY:{min:15,max:35},MOVEMENT_SPEED:{min:.03,max:.09},OPACITY:{min:.3,max:1},TIME_SPEED:{min:.1,max:3},RING_CYCLE_DURATION:{min:25,max:45},RING_EVENT_DURATION:{min:3,max:8},SEPARATION_DURATION:{min:.8,max:2.5},RETURNING_DURATION:{min:.8,max:2.5}};class U{group;doodles=[];doodleData=[];planetRadius;startTime;timeSpeed;rng;lightDirection=new g(1,1,1).normalize();cosmicRingState="normal";ringCycleDuration;ringEventDuration;separationDuration;returningDuration;doodleBasePositions=[];orbitalVisibilityFactor;orbitalData;currentTimeYears;createLitMaterial(t,i){const e=`
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        vWorldNormal = normalize(mat3(modelMatrix) * normal);
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,n=`
      uniform vec3 color;
      uniform float opacity;
      uniform vec3 lightDirection;
      uniform float ambientStrength;
      uniform float lightIntensity;
      
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      
      void main() {
        vec3 normal = normalize(vWorldNormal);
        vec3 lightDir = normalize(-lightDirection); // Negativo porque lightDirection apunta hacia la luz
        
        // Lambertian lighting with smooth day/night transition
        float dotNL = dot(normal, lightDir);
        float lightingFactor = max(0.0, dotNL); // Simple Lambertian
        
        // Rim lighting for enhanced visibility
        float rimLight = 1.0 - abs(dotNL);
        rimLight = pow(rimLight, 3.0) * 0.1;
        
        // Final lighting calculation with preserved color intensity
        float totalLight = ambientStrength + (lightIntensity * lightingFactor) + rimLight;
        totalLight = clamp(totalLight, 0.6, 1.2); // Higher minimum, allow slight overbrightening
        
        // Preserve color vibrancy by mixing original color with lit color
        vec3 finalColor = mix(color * 0.8, color * totalLight, 0.7);
        
        gl_FragColor = vec4(finalColor, opacity);
      }
    `;return new N({vertexShader:e,fragmentShader:n,uniforms:{color:{value:new L(t)},opacity:{value:i},lightDirection:{value:this.lightDirection.clone()},ambientStrength:{value:.5},lightIntensity:{value:.8}},transparent:!0,side:C})}projectPointOnSphere(t,i,e,n){const a=n.clone().normalize(),o=new g(0,1,0).cross(a).normalize();o.lengthSq()<.001&&o.set(1,0,0).cross(a).normalize();const c=a.clone().cross(o).normalize(),l=o.clone().multiplyScalar(t).add(c.clone().multiplyScalar(i));return a.clone().add(l).normalize().multiplyScalar(e)}constructor(t,i={},e){this.group=new M,this.planetRadius=t;const n=e||12345;this.rng=new z(n),this.startTime=n%1e4/1e3,this.timeSpeed=this.rng.uniform(s.TIME_SPEED.min,s.TIME_SPEED.max),this.ringEventDuration=this.rng.uniform(s.RING_EVENT_DURATION.min,s.RING_EVENT_DURATION.max),this.separationDuration=this.rng.uniform(s.SEPARATION_DURATION.min,s.SEPARATION_DURATION.max),this.returningDuration=this.rng.uniform(s.RETURNING_DURATION.min,s.RETURNING_DURATION.max);const a=this.rng.uniform(s.RING_CYCLE_DURATION.min,s.RING_CYCLE_DURATION.max);this.ringCycleDuration=a+this.ringEventDuration,this.orbitalData=i.orbitalData,this.currentTimeYears=i.currentTime||0,this.orbitalVisibilityFactor=this.calculateOrbitalVisibility(),this.doodleData=this.generateProceduralDoodles(),this.doodleData.length>0&&this.createDoodles()}generateProceduralDoodles(){const t=[],i=this.rng.randint(s.DOODLE_COUNT.min,s.DOODLE_COUNT.max),e=["arc","fractals","squiggle"],n=["wave","pulse","spiral"];for(let a=0;a<i;a++){const o=this.rng.random()*2*Math.PI,c=Math.acos(this.rng.random()*2-1),l=[Math.sin(c)*Math.cos(o),Math.sin(c)*Math.sin(o),Math.cos(c)],r=this.rng.randint(200,255),h=this.rng.randint(0,100),m=this.rng.randint(150,255),p=this.rng.uniform(s.OPACITY.min,s.OPACITY.max),d=`#${r.toString(16).padStart(2,"0")}${h.toString(16).padStart(2,"0")}${m.toString(16).padStart(2,"0")}`;console.log(`ExoticDoodle ${a}: ${d} (RGB: ${r}, ${h}, ${m})`),t.push({position_3d:l,type:e[this.rng.randint(0,e.length-1)],size:this.rng.uniform(s.DOODLE_SIZE.min,s.DOODLE_SIZE.max),color:[d,p],complexity:this.rng.randint(s.COMPLEXITY.min,s.COMPLEXITY.max),movement_speed:this.rng.uniform(s.MOVEMENT_SPEED.min,s.MOVEMENT_SPEED.max),movement_pattern:n[this.rng.randint(0,n.length-1)]})}return t}createDoodles(){this.doodleData.forEach((t,i)=>{let e;switch(t.type){case"arc":e=this.createArcDoodle(t);break;case"fractals":e=this.createFractalDoodle(t);break;case"squiggle":e=this.createSquiggleDoodle(t);break;default:e=this.createSquiggleDoodle(t)}const n=new g(...t.position_3d).normalize();this.doodleBasePositions[i]=n.multiplyScalar(this.planetRadius),this.doodles.push(e),this.group.add(e)})}createArcDoodle(t){const i=new M,n=new A(0,0,t.size*this.planetRadius,t.size*this.planetRadius*.7,0,Math.PI*1.5,!1,0).getPoints(50),a=new I().setFromPoints(n),o=this.createLitMaterial(t.color[0],t.color[1]),c=new v(a,o);return i.add(c),i}createFractalDoodle(t){const i=new M,e=Math.floor(t.complexity*.6)+2,n=new g(...t.position_3d),a=this.planetRadius;for(let o=0;o<e;o++){const c=(this.rng.random()-.5)*t.size*this.planetRadius,l=(this.rng.random()-.5)*t.size*this.planetRadius,r=[],h=Math.floor(this.rng.random()*20)+8,m=this.rng.random()*t.size*this.planetRadius*.3+.1;for(let f=0;f<=h;f++){const D=f/h*Math.PI*2,b=m*(.7+this.rng.random()*.6),S=D+(this.rng.random()-.5)*.5,y=c+Math.cos(S)*b,E=l+Math.sin(S)*b,_=this.projectPointOnSphere(y,E,a,n);r.push(_)}r.push(r[0]);const p=new I().setFromPoints(r),d=this.createLitMaterial(t.color[0],t.color[1]),u=new v(p,d);i.add(u)}return i}createSquiggleDoodle(t){const i=new M,e=Math.floor(t.complexity*.8)+3,n=new g(...t.position_3d),a=this.planetRadius;for(let o=0;o<e;o++){const c=[],l=this.rng.random()*15+5;let r=(this.rng.random()-.5)*t.size*this.planetRadius,h=(this.rng.random()-.5)*t.size*this.planetRadius;for(let u=0;u<=l;u++){const f=this.projectPointOnSphere(r,h,a,n);c.push(f),r+=(this.rng.random()-.5)*t.size*this.planetRadius*.2,h+=(this.rng.random()-.5)*t.size*this.planetRadius*.2;const D=t.size*this.planetRadius*.8;r=Math.max(-D,Math.min(D,r)),h=Math.max(-D,Math.min(D,h))}const m=new I().setFromPoints(c),p=this.createLitMaterial(t.color[0],t.color[1]),d=new v(m,p);i.add(d)}return i}update(t){const e=(this.startTime+Date.now()/1e3*this.timeSpeed)%1e3;if(this.orbitalVisibilityFactor=this.calculateOrbitalVisibility(),this.orbitalVisibilityFactor<=.001){this.cosmicRingState="normal",this.doodles.forEach(a=>{a.position.set(0,0,0)}),this.applyNormalAnimations(e);return}const n=e%this.ringCycleDuration;this.updateCosmicRingState(n),this.doodles.forEach((a,o)=>{const c=this.doodleData[o];if(!c)return;const l=this.calculateCosmicRingEffect(n,o),r=new g(0,0,0),h=this.doodleBasePositions[o],m=o%3,p=this.planetRadius*2.5,d=m*.3*this.planetRadius,u=h.clone().normalize().multiplyScalar(p+d),D=e*12,b=1+m*.4,S=D*b+o*(Math.PI*2/this.doodles.length),y=p*.08,E=new g().crossVectors(u,new g(0,1,0)).normalize();E.lengthSq()<.001&&E.set(1,0,0).cross(u.clone().normalize()).normalize();const _=new g().crossVectors(u.clone().normalize(),E).normalize(),x=u.clone().add(E.multiplyScalar(Math.cos(S)*y)).add(_.multiplyScalar(Math.sin(S)*y));let P;if(l.separationFactor<=.001)P=r.clone();else{let R=l.separationFactor;this.cosmicRingState==="separating"?R=this.easeOutQuart(R):this.cosmicRingState==="returning"&&(R=this.easeInOutCubic(R)),P=r.clone().lerp(x,R)}a.position.copy(P);const T=c.movement_speed*l.speedMultiplier;switch(c.movement_pattern){case"wave":a.rotation.z=Math.sin(e*T)*.2;break;case"pulse":a.rotation.z=Math.sin(e*T*2)*.15;break;case"spiral":a.rotation.z=e*T;break}})}calculateOrbitalVisibility(){if(!this.orbitalData||!this.orbitalData.enabled)return 1;const i=this.currentTimeYears%this.orbitalData.cycle_duration_years/this.orbitalData.cycle_duration_years,e=this.orbitalData.visible_duration_years/this.orbitalData.cycle_duration_years;if(i<e){const n=i/e;return n<.1?n/.1:n>.9?(1-n)/.1:1}else return 0}applyNormalAnimations(t){this.doodles.forEach((i,e)=>{const n=this.doodleData[e];if(!n)return;const a=n.movement_speed;switch(n.movement_pattern){case"wave":i.rotation.z=Math.sin(t*a)*.2;break;case"pulse":i.rotation.z=Math.sin(t*a*2)*.15;break;case"spiral":i.rotation.z=t*a;break}})}updateCosmicRingState(t){const i=this.ringCycleDuration-this.ringEventDuration;t<i?this.cosmicRingState="normal":t<i+this.separationDuration?this.cosmicRingState="separating":t<i+this.separationDuration+(this.ringEventDuration-this.separationDuration-this.returningDuration)?this.cosmicRingState="ring_mode":this.cosmicRingState="returning"}calculateCosmicRingEffect(t,i){const e=this.ringCycleDuration-this.ringEventDuration;let n=0,a=0,o=1;switch(this.cosmicRingState){case"normal":n=0,a=0,o=1;break;case"separating":const l=(t-e)/this.separationDuration;n=this.easeOutQuart(l),a=12,o=1+n*7;break;case"ring_mode":n=1,a=12,o=8;break;case"returning":const r=e+this.separationDuration+(this.ringEventDuration-this.separationDuration-this.returningDuration),h=(t-r)/this.returningDuration;n=1-this.easeInQuart(h),a=12,o=1+n*7;break}const c=i/this.doodles.length*.3;if(this.cosmicRingState==="separating"){const l=Math.max(0,(t-e-c*this.separationDuration)/this.separationDuration);n=this.easeOutQuart(l)}else if(this.cosmicRingState==="returning"){const l=e+this.separationDuration+(this.ringEventDuration-this.separationDuration-this.returningDuration),r=Math.max(0,(t-l-c*this.returningDuration)/this.returningDuration);n=1-this.easeInQuart(r)}return{separationFactor:n,orbitalSpeed:a,speedMultiplier:o}}smoothstep(t,i,e){const n=Math.max(0,Math.min(1,(e-t)/(i-t)));return n*n*(3-2*n)}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}easeOutQuart(t){return 1-Math.pow(1-t,4)}easeInQuart(t){return t*t*t*t}updateLightDirection(t){this.lightDirection.copy(t).normalize(),this.doodles.forEach(i=>{i.traverse(e=>{e instanceof v&&e.material instanceof N&&e.material.uniforms.lightDirection&&e.material.uniforms.lightDirection.value.copy(this.lightDirection)})})}updateFromThreeLight(t){const i=t.position.clone().normalize();this.updateLightDirection(i)}addToScene(t,i){this.group.position.copy(i),t.add(this.group)}removeFromScene(t){t.remove(this.group)}getObject3D(){return this.group}dispose(){this.doodles.forEach(t=>{t.traverse(i=>{i instanceof F?(i.geometry.dispose(),i.material instanceof w&&i.material.dispose()):i instanceof v&&(i.geometry.dispose(),i.material instanceof w&&i.material.dispose())})}),this.doodles=[]}}function k(O,t,i,e){const a=e?.surface_elements?.exotic_doodles;return new U(O,{planetRadius:O,orbitalData:a,currentTime:0},i)}export{U as E,k as c};
