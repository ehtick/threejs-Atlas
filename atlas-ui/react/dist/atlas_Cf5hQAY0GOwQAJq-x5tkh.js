import{D as p,S}from"./atlas_DX8SEIp2JtnHgjTmbPtX-.js";import{G as O,O as L,z as _,C as T,M as A,V as f,B as I,g as M,S as y,o as b}from"./atlas_DUxdE5_5iPCKlmI6uaLFO.js";const m={SATELLITE_COUNT:{min:1,max:10},SATELLITE_DISTANCE:{min:.8,max:1.2},ORBITAL_SPEED:{min:.4,max:1}};class C{group;satellites=[];trails=[];trailPositions=[];params;rng;planetRadius;cosmicOffset;TRAIL_LENGTH=15;constructor(t,i={}){this.planetRadius=t;const s=i.seed||Math.floor(Math.random()*1e6);this.rng=new S(s),this.params={color:i.color||[1,1,.8],satelliteCount:i.satelliteCount||Math.floor(this.rng.random()*(m.SATELLITE_COUNT.max-m.SATELLITE_COUNT.min)+m.SATELLITE_COUNT.min),satelliteDistance:i.satelliteDistance||this.rng.random()*(m.SATELLITE_DISTANCE.max-m.SATELLITE_DISTANCE.min)+m.SATELLITE_DISTANCE.min,orbitalSpeed:i.orbitalSpeed||this.rng.random()*(m.ORBITAL_SPEED.max-m.ORBITAL_SPEED.min)+m.ORBITAL_SPEED.min,cosmicOriginTime:i.cosmicOriginTime||p,seed:s},this.cosmicOffset=s%100*.1,this.group=new O,this.createSatellites()}createSatellites(){const t=this.params.satelliteCount,i=this.planetRadius+this.params.satelliteDistance;for(let s=0;s<t;s++){const o=i,n=this.rng.random()*Math.PI,r=this.rng.random()*Math.PI*2,e=this.rng.random()*Math.PI*2,a=this.calculateOrbitalPosition(o,n,r,e),l=new L(this.planetRadius*.025,0),h=new _({color:new T(this.params.color[0],this.params.color[1],this.params.color[2]),transparent:!1,opacity:1}),c=new A(l,h);c.position.set(a.x,a.y,a.z),c.userData={distance:o,inclination:n,longitudeOfAscendingNode:r,initialAngle:e,orbitalSpeed:this.rng.random()*.5+.5},this.satellites.push(c),this.group.add(c),this.createTrail(s)}}createTrail(t){const i=[],s=[];for(let e=0;e<this.TRAIL_LENGTH;e++){i.push(new f(0,0,0));const a=(this.TRAIL_LENGTH-e)/this.TRAIL_LENGTH;s.push(a)}this.trailPositions[t]=i;const o=new I().setFromPoints(i);o.setAttribute("opacity",new M(s,1));const n=new y({uniforms:{color:{value:new T(this.params.color[0],this.params.color[1],this.params.color[2])}},vertexShader:`
        attribute float opacity;
        varying float vOpacity;
        
        void main() {
          vOpacity = opacity;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,fragmentShader:`
        uniform vec3 color;
        varying float vOpacity;
        
        void main() {
          gl_FragColor = vec4(color, vOpacity);
        }
      `,transparent:!0,depthWrite:!1}),r=new b(o,n);r.renderOrder=998,this.trails.push(r),this.group.add(r)}calculateOrbitalPosition(t,i,s,o){const n=t*Math.cos(o),r=t*Math.sin(o),e=0,a=n,l=r*Math.cos(i)-e*Math.sin(i),h=r*Math.sin(i)+e*Math.cos(i),c=a*Math.cos(s)-l*Math.sin(s),d=a*Math.sin(s)+l*Math.cos(s),u=h;return new f(c,d,u)}update(t){const o=(Date.now()/1e3-(this.params.cosmicOriginTime||p)+this.cosmicOffset)*(this.params.orbitalSpeed||1);this.satellites.forEach((n,r)=>{const e=n.userData,a=e.initialAngle+o*e.orbitalSpeed*.1,l=this.calculateOrbitalPosition(e.distance,e.inclination,e.longitudeOfAscendingNode,a);n.position.set(l.x,l.y,l.z),n.rotation.y=a,this.updateTrailWithInterpolation(r)})}updateTrailWithInterpolation(t){const i=this.trailPositions[t],o=this.satellites[t].userData,e=(Date.now()/1e3-(this.params.cosmicOriginTime||p)+this.cosmicOffset)*(this.params.orbitalSpeed||1),a=o.initialAngle+e*o.orbitalSpeed*.1;for(let c=0;c<this.TRAIL_LENGTH;c++){const d=c*.05,u=a-d,E=this.calculateOrbitalPosition(o.distance,o.inclination,o.longitudeOfAscendingNode,u);i[c].copy(E)}const h=this.trails[t].geometry;h.setFromPoints(i),h.attributes.position.needsUpdate=!0}getObject3D(){return this.group}addToScene(t,i){i&&this.group.position.copy(i),t.add(this.group)}removeFromScene(t){t.remove(this.group)}dispose(){this.satellites.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.trails.forEach(t=>{t.geometry.dispose(),t.material.dispose()}),this.group.clear()}setEnabled(t){this.group.visible=t}updateParams(t){if(Object.assign(this.params,t),t.color){const i=new T(t.color[0],t.color[1],t.color[2]);this.satellites.forEach(s=>{s.material.color=i}),this.trails.forEach(s=>{const o=s.material;o.uniforms.color.value=i})}}}function R(g,t,i){const o={seed:(i||Math.floor(Math.random()*1e6))+90001,color:t.color||[1,1,.8],cosmicOriginTime:t?.timing?.cosmic_origin_time||t?.cosmicOriginTime||p};return new C(g,o)}export{C as L,R as c};
